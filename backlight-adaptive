#!/usr/bin/env sh
#
# Copyright (c) 2020 Nikita Zlobin <nick87720z@gmail.com>
#
# backlight-adaptive is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# backlight-adaptive is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

startup_args="$*"
progname=backlight-adaptive
backends_all=internal,light,xbacklight

# Default parameters

watch_conf=true
delay=0.1
grab=true
log_level=info
log_color=false

max_color=35
maxbright=100
minbright=1
fade_frames=0

acpi_dev=
backends="${backends_all}"
backend_args=

toggle=false

for vdev in /dev/video* ; do break; done

isnum() {
        for n in "$@"; do case ${n#[+-]} in
        ''|*[!0-9.]* | '.' | *.*.*) return 1
        esac; done
}

# Config - find & load or create new

print_options() {
        while [ $# -gt 0 ]; do
                eval printf '%s\\n' "$1=\$$1"
                shift
        done
}

save_config() {
        print_options watch_conf fade_frames delay grab log_level log_color max_color maxbright minbright acpi_dev backends backend_args | sort > "${config_file}"
}

# Search for either config file or writable config dir
for config_dir in "${XDG_CONFIG_PATH}" ~/.config /etc ; do
        [ -f "${config_dir}/${progname}" -o \( -d "${config_dir}" -a -w "${config_dir}" \) ] && break
        config_dir=
done

# Either read existing or create new config
if [ -n "${config_dir}" ]
then
        config_file="${config_dir}/${progname}"
        if [ -f "${config_file}" ]
        then
                { while IFS='=' read name v; do
                        case $name in
                        watch_conf  )
                                case "$v" in true | false )
                                        watch_conf="$v"
                                esac
                                continue;;
                        acpi_dev    ) acpi_dev="$v";     continue;;
                        backend_args) backend_args="$v"; continue;;
                        backends    ) backends="$v";     continue;;
                        delay       )
                                if isnum "$v"; then
                                        delay="$v"
                                fi
                                continue;;
                        fade_frames )
                                if isnum "$v"; then
                                        fade_frames="$v"
                                fi
                                continue;;
                        grab        ) grab="$v";         continue;;
                        log_level   )
                                if isnum "$v"; then
                                        log_level="$v"
                                fi
                                continue;;
                        log_color   )
                                case "$v" in true | false )
                                        log_color="$v"
                                esac
                                continue;;
                        maxbright   )
                                if isnum "$v"; then
                                        maxbright="$v"
                                fi
                                continue;;
                        max_color   )
                                if isnum "$v"; then
                                        max_color="$v"
                                fi
                                continue;;
                        minbright   )
                                if isnum "$v"; then
                                        minbright="$v"
                                fi
                                continue;;
                        * )
                                printf '%s\n' "Unknown config option '${name}'"
                                continue;;
                        esac
                done; } < ~/.config/${progname}
        elif touch "${config_file}"; then
                save_config
        else
                unset config_file
        fi
fi

show_help() {
        printf '%s\n' "Usage: $(basename $0) [options] -- [backend options]"
        printf '%s\n' "Options:"
        printf '%s\n' "-d, --delay     FLOAT       Snapshots delay (seconds)"
        printf '%s\n' "-g, --no-grab               Don't keep camera busy all time"
        printf '%s\n' "-a, --acpi-dev  NAME        ACPI device to be controlled"
        printf '%s\n' "-v, --video-dev DEVICE      Video device used as sensor (e.g. /dev/video0)"
        printf '%s\n' "-b, --backends  STR,STR...  Comma-separated list of backlight control backends"
        printf '%s\n' "-B, --list-backends         List available backends"
        printf '%s\n' "-l, --log       STRING      Log verbosity. One of: error, warning, info, debug"
        printf '%s\n' "-c, --color     BOOLEAN     Colorize output"
        printf '%s\n' "    --bl-max    FLOAT       Maximum backlight level (%)"
        printf '%s\n' "    --bl-min    FLOAT       Minimum backlight level (%)"
        printf '%s\n' "    --max-color INTEGER     Color value for full backlight level"
        printf '%s\n' "-s, --smooth    INTEGER     Frames number to smooth (0 to disable)"
        printf '%s\n' "-t, --toggle                Stop runing instance or run as new"
        printf '%s\n' "-w, --watchconf BOOLEAN     Auto-restart when configuration file is changed"
        printf '%s\n' "-h, --help                  Show this help"
}

# Arguments loading

while [ $# -gt 0 ]; do
        case $1 in
        '-d' | '--delay' )
                if isnum "$2"; then
                        delay="$2"
                fi
                shift ;;
        '-g' | '--no-grab' ) grab=false ;;
        '-l' | '--log' )
                if isnum "$2"; then
                        log_level="$2"
                fi
                shift ;;
        '-c' | '--color'   )
                case "$2" in true | false )
                        log_color="$2"
                esac; shift ;;
        '--bl-max' )
                if isnum "$2"; then
                        maxbright="$2"
                fi
                shift ;;
        '--bl-min' )
                if isnum "$2"; then
                        minbright="$2"
                fi
                shift ;;
        '--max-color' )
                if isnum "$2"; then
                        max_color="$2"
                fi
                shift ;;
        '-s' | '--smooth' )
                if isnum "$2"; then
                        fade_frames=$(( $2 < 0 ? 0 : $2 ))
                fi
                shift ;;
        '-a' | '--acpi-dev' ) acpi_dev="$2"
                shift ;;
        '-v' | '--video-dev' ) vdev="$2"
                shift ;;
        '-b' | '--backends' ) backends="$2"
                shift ;;
        '-B' | '--list-backends' ) printf '%s\n' "${backends_all}"
                exit ;;
        '-t' | '--toggle' ) toggle=true;;
        '-w' | '--watchconf' )
                case "$2" in true | false )
                        watchconf="$2"
                esac; shift ;;
        '-h' | '--help' ) show_help
                exit ;;
        '--' ) backend_args="$*"
                break ;;
        esac
        shift
done

# Configure terminal font controls

if ! ${log_color}; then
        tput() { :; }
fi

# create color table
i=0; for c in black red green yellow blue pink cyan gray; do
        eval "$c=$i"
        i=$(( i+1 ))
done; unset i c
isnum() {
        for n in "$@"; do case ${n#[+-]} in
        ''|*[!0-9.]* | '.' | *.*.*) return 1
        esac; done
}
# color set helper
col() {
        if isnum $1; then
                tput setaf $1
        else
                eval exec tput setaf \$$1
        fi
        if [ $# -gt 2 ]; then
                if isnum $2; then
                        tput setab $2
                else
                        eval exec tput setab \$$2
                fi
        fi
}
# other control strings
bold="$(tput bold)"
sgr0="$(tput sgr0)"

# Loging features

i=0; for l in error warning info debug; do
        eval $l=$i
        i=$(( i+1 ))
done; unset i l
eval log_level_n=\$$log_level

msg_color() {
        local c=$1
        shift
        printf '%s\n' "$(col $c)$*$sgr0"
}
msg_debug()   { [ $log_level_n -ge $debug   ] && printf '%s\n' "$*${sgr0}"; }
msg_info()    { [ $log_level_n -ge $info    ] && msg_color blue   "$*"; }
msg_warning() { [ $log_level_n -ge $warning ] && msg_color yellow "$*"; }
msg_error()   { [ $log_level_n -ge $error   ] && msg_color red    "$*"; }

fatal() {
        msg_error "$@"
        exit 1
}

msg_info "Config file: ${bold}$(col green)${config_file}"

# Depepdency check

msg_info "Checking dependencies"
for dep in tput inotifywait ffmpeg tr awk v4l2-ctl; do
        if ! [ "$(which $dep 2>/dev/null)" ]; then
                msg_error "${dep} executable required but not found"
                abort=1
        fi
done
# binary stream printer
for hextool in hexdump od; do
        if which $hextool > /dev/null; then
                break
        fi
        hextool=
done
case "$hextool" in
        hexdump )
                byteorder_test='hexdump -x'
                hexprinter="hexdump -v -e '1/2 \"%u\\n\"'"
        ;;
        od )
                byteorder_test='od -x'
                hexprinter='od -v -An -w2 -tu2'
        ;;
        * )
                abort=1
                msg_error "Either hexdump or od are required"
        ;;
esac
if [ "$abort" ]; then
        exit 1
fi
msg_info "Found hex printer: ${bold}$(col green)${hextool}"
msg_debug "hexprinter: ${hexprinter}"
msg_debug "byteorder_test: ${byteorder_test}"

# Choose backlight control tool

msg_info "Searching usable backend"
if [ ! "${backends}" ]; then
        fatal "Backends are not set"
fi
for backend in $( printf '%s' "$backends" | tr ',' ' ' ) ; do
        msg_info "Checking backend ${bold}$(col green)$backend"
        bl_max=${maxbright}
        bl_min=${minbright}
        case "$backend" in
        light )
                which ${backend} >/dev/null 2>&1 || continue
                bl_get_cmd='light -G'
                bl_sh="sh"
                bl_fmt="light -S %f ${backend_args}\n"
                break
        ;;
        xbacklight )
                which ${backend} >/dev/null 2>&1 || continue
                bl_get_cmd='xbacklight -get'
                bl_sh="sh"
                bl_fmt="xbacklight -set %f ${backend_args}\n"
                break
        ;;
        internal )
                acpi_dir="/sys/class/backlight"

                # ACPI dir exists and is not empty
                if ! [ -d "${acpi_dir}" ] ; then
                        msg_error "No ACPI support found"
                        break
                fi


                # Use first entry if acpi_dev not set
                if [ "${acpi_dev}" ] && { [ -d "${acpi_dir}/${acpi_dev}" ] || ! msg_warning "ACPI device ${acpi_dev} not found"; }; then
                        acpi_dir="${acpi_dir}/${acpi_dev}"
                else
                        for acpi_dir in "${acpi_dir}"/* ; do break; done
                        if ! [ -d "${acpi_dir}" -a -f "${acpi_dir}/brightness" ]; then
                                msg_error "No ACPI backlight devices found"
                                break
                        fi
                fi
                
                # Translate brightness limits to raw backlight range
                bl_max=$(( maxbright * $(cat ${acpi_dir}/max_brightness) / 100 ))
                bl_min=$(( minbright * $(cat ${acpi_dir}/max_brightness) / 100 ))

                bl_get_cmd="cat '${acpi_dir}/brightness'"
                bl_sh="cat > '${acpi_dir}/brightness'"
                bl_fmt='%u\n'

                break
        ;;
        esac
        backend=
done
if [ ! "${backend}" ]; then
        fatal "No working backends found"
fi
msg_info "Using backend ${bold}$(col green)${backend}"
msg_debug "bl_get_cmd: $bl_get_cmd"
msg_debug "bl_sh     : $bl_sh"
msg_debug "bl_fmt    : $bl_fmt"

# Setup temporary dir

for path in "/var/run" "${XDG_RUNTIME_DIR}" "/tmp" "~/.cache"; do
        # Check base path
        [ "${path}" -a -d "${path}" -a -w "${path}" ] || continue
        tmpdir="${path}/${progname}"
        pidfile="$tmpdir/pid"
        break
done
# No place for tmpdir
if [ ! "${tmpdir}" ]; then
        fatal "Can't find place for temporary directory"
fi
msg_info "Temporary directory: ${bold}$(col green)${tmpdir}"

if [ ! -e "${tmpdir}" ]; then
        mkdir -p "${tmpdir}"
elif ! [ -d "${path}" -a -w "${path}" ]; then
        fatal "$tmpdir: Not a directory"
elif [ -f "$pidfile" ]; then
        # We are singleton

        read pid < $pidfile
        if [ "$pid" -a "$(ps $pid | grep $pid)" ] ; then
                if $toggle; then
                        msg_info "Terminating instance $pid"
                        kill $pid
                else
                        msg_warning "Found runing instance, exiting."
                fi
                exit
        fi
fi

printf '%s\n' "$$" > "$pidfile"

# Event loop setup

quit() {
        state=int
        kill -- -$procpid
}

restart() {
        state=restart
        kill -- -$procpid
}

input_max() {
        state=input_max
        kill -- -$procpid
}

trap "quit"    INT TERM QUIT HUP
trap "restart" USR1
trap "input_max" USR2

# Processing pipeline

awk_expr() {
        printf '\n' | awk '{ printf ("%.17g", '"$1"') }'
}

awk_cmd() {
        printf '\n' | awk "{ $* }"
}

set -m

msg_info "Smoothing duration: $fade_frames frames"

msg_debug '=== Processing start ==='
b='stdbuf -oL'
frames=$($grab || printf -- '-frames 1')
pix_fmt=$( printf '\x11' | $byteorder_test | awk 'FNR==1 { print substr($2,4,1) ? "gray16le" : "gray16be" }' )
ifps=$( awk_cmd 'sprintf ("v4l2-ctl --device '${vdev}' -p %i\n", 1 / '$delay') | getline; print $5' )
ffmpeg_cmd='stdbuf -o0 ffmpeg -v $([ $log_level_n -ge $debug ] && printf verbose || printf quiet) \
        -f v4l2 -s 1x1 -r "${ifps}" -i "${vdev}"  \
        -vf scale=1:1:flags=area+accurate_rnd+print_info,format=${pix_fmt} \
        ${frames} -vcodec rawvideo -f rawvideo -r 1/${delay} -'
msg_debug "pix_fmt  : $pix_fmt"
msg_debug "=== ffmpeg_cmd ============"
msg_debug "${ffmpeg_cmd}"
msg_debug "==========================="
( { 
        if $grab; then
                eval exec "${ffmpeg_cmd}"
        else while :; do
                sleep $delay | eval exec "${ffmpeg_cmd}"
        done; fi
  } </dev/null  \
  | eval "exec $b $hexprinter" \
  | $b awk \
        -v bl_fmt="${bl_fmt}" \
        "function to_log(x) {
                return $bl_min + log(x / $bl_min) * d_log_r
        }
        function from_log(x) {
                return $bl_min * r^((x - $bl_min) / d)
        }
        BEGIN {
                stderr = \"/dev/stderr\"
                bl_sh = \"exec ${bl_sh} 2>/dev/null\"
                PROCINFO[bl_sh, \"NONFATAL\"]=1
                errno_prev = 0
                errno_num = 0

                # speedup calculations
                imax = 255 ; omax = 65535
                bl_cur = $( eval exec "$bl_get_cmd" )
                bl_fm = imax * ($bl_max - $bl_min)
                bl_fd = ($max_color * omax)
                r = $bl_max / $bl_min
                d = $bl_max - $bl_min
                d_log_r = d / log(r)

                # init LPF
                stage_frames = int( $fade_frames / 3 )
                bl_step = stage_frames > 0 ? r^( 1 / ($fade_frames - stage_frames)) : 0
                bl_log = to_log(bl_cur)
                for (fi = 0; fi < stage_frames; fi += 1)
                        fbuf[fi] = bl_log
                fi = 0
                fsum = bl_log * stage_frames

                # Minimum possible precision for sum in box filter
                # used to contain numeric unstability by rounding samples to this precision before filter
                prec_diff = int( log(stage_frames * $bl_max) / log(2) ) + 1
                rnd_mul = stage_frames > 0 ? 2^(PREC - prec_diff) : 0

        }

        # start
        {
                # map to backlight range
                bl = $bl_min + \$1 * bl_fm / bl_fd
                bl = bl > $bl_max ? $bl_max : bl < $bl_min ? $bl_min : bl

                if (bl_step > 0) {
                        if (bl > bl_cur ? (bl_cur *= bl_step) > bl : (bl_cur /= bl_step) < bl)
                                bl_cur = bl

                        # sliding box filter to smooth linear transition

                        p = int(to_log(bl_cur) * rnd_mul) / rnd_mul
                        fsum = fsum + p - fbuf[fi]
                        fbuf[fi] = p
                        fi = (fi + 1) % stage_frames
                        p = from_log(fsum / stage_frames)

                        # fix bounds violation due to unstability
                        # unstability is contained but not removed
                        p = p > $bl_max ? $bl_max : p < $bl_min ? $bl_min : p

                        if (bl == p) next
                } else {
                        if (bl == p) next
                        p = bl
                }
        }

        $(( log_level_n >= debug )) {
                "'printf ("brightness: %.02f%% input light: %u\n", 100 * p / '$bl_max', $1 / 256) > stderr'"
        }
        
        # output
        { 
                ERRNO=0
                printf (bl_fmt, p) | bl_sh

                if (ERRNO) {
                        if ( $(( log_level_n >= debug )) )
                        {
                                if (ERRNO == errno_prev)
                                        errno_num += 1
                                else
                                        errno_num = 0
                                errno_prev = ERRNO
                                "'printf (bl_sh": %s%s\r", ERRNO, errno_num > 0 ? sprintf(": %u times", errno_num) : "") > stderr'"
                        }
                        close (bl_sh)
                } else {
                        fflush (bl_sh)
                }
        }"
) & procpid=$!

state=run

# Monitor config changes
if $watch_conf && [ -n "$config_file" ]; then {
        inotifywait -q -e modify "$config_file"
        msg_info "Configuration changed"
        kill -s USR1 $$
} & monpid=$!; fi

# silence job control
set +m

# Waiting

msg_debug "Waiting for events"
wait $procpid
if [ -n "$monpid" ]; then
        kill -- -$monpid
fi

while :; do
        case $state in
        'int'    )
                msg_info Interrupted; 
                exit ;;
        'restart')
                msg_info 'Restart...'; rm $pidfile; 
                eval exec "$0 $startup_args" ;;
        'input_max' )
                frames=1
                max_color=$( ffmpeg -v quiet -f v4l2 -s 1x1 -i "${vdev}" -frames 1 -vcodec rawvideo -f rawvideo -vf scale=1:1:flags=area+accurate_rnd,format=gray - | od -An -w1 -tu1 | tr -d ' ' )
                msg_info "New light maximum: $max_color / 255"
                save_config

                state=restart
                continue ;;
        'run'    )
                msg_warning 'Pipeline terminated on its own'; 
                exit ;;
        esac
        break
done

